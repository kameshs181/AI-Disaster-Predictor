from flask import Flask, render_template, request, jsonify, redirect, url_for, session
import joblib, requests, pandas as pd, sqlite3, os
from dotenv import load_dotenv
from flask_bcrypt import Bcrypt

load_dotenv()

app = Flask(__name__)
bcrypt = Bcrypt(app)
app.secret_key = os.getenv("SECRET_KEY")

DB = "users.db"
API_KEY = os.getenv("OPENWEATHER_API_KEY")

# ========================
# Database setup
# ========================
def init_db():
    if not os.path.exists(DB):
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("""
            CREATE TABLE users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                email TEXT UNIQUE,
                password TEXT
            )
        """)
        conn.commit()
        conn.close()
init_db()

# ========================
# Load Models
# ========================
flood_model = joblib.load("models/flood_model.pkl")
cyclone_model = joblib.load("models/cyclone_model.pkl")

# ========================
# Helper functions
# ========================
def get_live_weather(city):
    url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric"
    r = requests.get(url)
    if r.status_code != 200:
        return None
    d = r.json()
    return {
        "temp": d["main"]["temp"],
        "humidity": d["main"]["humidity"],
        "pressure": d["main"]["pressure"],
        "rainfall": d.get("rain", {}).get("1h", 0.0),
        "lat": d["coord"]["lat"],
        "lon": d["coord"]["lon"]
    }

def risk_level(prob):
    if prob < 0.4: return "Low"
    elif prob < 0.7: return "Medium"
    else: return "High"

# ========================
# Auth Routes
# ========================
@app.route('/')
def home():
    return redirect(url_for('login'))

@app.route('/login', methods=['GET','POST'])
def login():
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("SELECT * FROM users WHERE email=?", (email,))
        user = c.fetchone()
        conn.close()
        if user and bcrypt.check_password_hash(user[3], password):
            session['user'] = user[1]
            return redirect(url_for('dashboard'))
        return render_template('login.html', error="Invalid credentials")
    return render_template('login.html')

@app.route('/register', methods=['GET','POST'])
def register():
    if request.method == 'POST':
        name = request.form['name']
        email = request.form['email']
        password = bcrypt.generate_password_hash(request.form['password']).decode('utf-8')
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        try:
            c.execute("INSERT INTO users (name, email, password) VALUES (?,?,?)", (name, email, password))
            conn.commit()
        except:
            return render_template('register.html', error="Email already registered")
        conn.close()
        return redirect(url_for('login'))
    return render_template('register.html')

@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('login'))

# ========================
# Dashboard
# ========================
@app.route('/dashboard')
def dashboard():
    if 'user' not in session:
        return redirect(url_for('login'))
    return render_template('dashboard.html', user=session['user'])

# ========================
# Prediction API
# ========================
@app.route('/predict', methods=['POST'])
def predict():
    data = request.get_json()
    city = data.get("city")
    weather = get_live_weather(city)
    if not weather:
        return jsonify({"error": "City not found"})

    # Simple live model inference
    flood_prob = round((weather["humidity"]/100) * (weather["rainfall"]/10 + 0.3), 2)
    cyclone_prob = round((weather["temp"]/40) * (weather["pressure"]/1000 + 0.2), 2)

    result = {
        "city": city.capitalize(),
        "weather": weather,
        "flood_prob": flood_prob,
        "flood_risk": risk_level(flood_prob),
        "cyclone_prob": cyclone_prob,
        "cyclone_risk": risk_level(cyclone_prob)
    }
    return jsonify(result)

if __name__ == '__main__':
    app.run(debug=True)
